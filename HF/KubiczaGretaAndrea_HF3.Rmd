---
title: "3. házi feladat (HF3)"
output: html_document
---

Beadási határidő: október 25. éjfél

Beküldés: a Microsoft Teams felületén keresztül

Adj szöveges választ is, ahol a feladatkitűzés ezt kéri!

---

## 1. feladat (HF3/1) (10 pont)

Ebben a feladatban a 2016-os riói olimpián részt vett sportolók adatait fogjuk elemezni.

**a)** (1 pont)

- Töltsd be a sportolók adatait tartlmazó [csv fájlt](https://raw.githubusercontent.com/flother/rio2016/master/athletes.csv) egy R data frame-be (közvetlenül az internetről, a fájl saját gépre való letöltése nélkül).
```{r}
athletes <- read.csv(url('https://raw.githubusercontent.com/flother/rio2016/master/athletes.csv'), sep=',', header = TRUE)
```

- Írj egy olyan függvényt, mely nemzetenként (a bemenő paraméter az országkód) meghatározza az adott ország (2016-ban) többszörösen érmes sportolóit!
```{r}
ermek <- function(orszagkod){
  tobberem = athletes[athletes$nationality == orszagkod & (athletes$gold + athletes$silver + athletes$bronze) > 1, ]
  tobberem$name
}
```

- Írd ki a többszörösen érmes magyar sportolók neveit megszerzett érmeik típusával és számával együtt!
```{r}
magyarok <- ermek('HUN')

for(i in magyarok) {
  magyar <- athletes[athletes$name == i, ]
  print(paste(magyar$name, magyar$gold, "aranyérmet,", magyar$silver, "ezüstérmet és ", magyar$bronze, "bronzértmet szerzett."))
}
```

**b)** (1 pont)

A órán bemutatott Notebook02-ben írtunk egy Python függvényt, mely a születési időből meghatározta a kort.

- Hasonló logika alapján írj egy ilyen R függvényt!
<p>><font size=2>Tipp: használd az *as.POSIXlt* függvényt!</font></p>
```{r}
toage <- function(birth){
  kulonbseg <- as.Date("2016-08-05") - as.Date(birth)
  kor <- as.numeric(kulonbseg)%/%365.25
  return(kor)
}
```

- Az előbb definiált függvény segítségével adj hozzá a data frame-hez egy új oszlopot, amiben megadod, hogy a sportoló hány éves volt az olimpia nyitónapján.
```{r}
korok <- c()
for(i in 1:length(athletes$id)) {
  korok[i] <- toage(athletes[i, 'date_of_birth'])
}
```
```{r}
athletes['age']<- korok
```

**c)** (2 pont)

Hisztogramok készítése

- Ábrázold a női és férfi sportolók magasságának eloszlását külön-külön hisztogramon, de a hisztogramokat helyezd ugyanarra az ábrára különböző színekkel! Figyelj a színezésnél a hisztogramok átfedő részeire is! <p>><font size=2>Tipp: a ggplot függvényben használd az aes(x = height, fill = sex) opciót!</font></p>
```{r}
#install.packages("ggplot2")
```
```{r}
library("ggplot2")
```
```{r}
ggplot(athletes, aes(x = height, fill = sex)) + geom_histogram(alpha = 0.5, aes(y = ..count..), position = 'identity', na.rm = TRUE, bins = 30)
```

- Készíts egy új ábrát, de most a *+ geom_histogram()* függvényben használd az *aes(y = ..density..)* opciót! Az ábrához adj hozzá egy-egy az adatokra illesztett normális sűrűségfüggvényt nemenként külön-külön!
<p>><font size=2>Tipp: használd a *+ stat_function(fun = dnorm)* függvényt a megfelelő paraméterekkel!</font></p>
```{r}
fml <- athletes[athletes$sex == "female", ]
ml <- athletes[athletes$sex == "male", ]
```
```{r}
ggplot(athletes, aes(x = height, fill = sex)) + geom_histogram(alpha = 0.5, aes(y = ..density..), position = 'identity', na.rm = TRUE, bins = 30) +
  stat_function(data = fml, aes(colour = "female"), fun =  dnorm, args = list(mean = mean(fml$height, na.rm = TRUE), sd = sd(fml$height, na.rm = TRUE))) +
  stat_function(data = ml, aes(colour = "male"), fun = dnorm, args = list(mean = mean(ml$height, na.rm = TRUE), sd = sd(ml$height, na.rm = TRUE)))
```

**d)** (1 pont)

Tekintsük az alábbi három sportág férfi sportolóit: kosárlabda, gimnasztika, birkózás.

- Ábrázold pontdiagramon ezeket a sportolókat, úgy hogy az x-tengelyen a sportoló magassága, az y-tengelyen pedig a sportoló súlya jelenjen meg. A pontok színe a három sportág szerint legyen különböző.
```{r}
mls <- ml[ml$sport == "basketball" | ml$sport == "gymnastics" | ml$sport == "wrestling", ]
```
```{r}
ggplot(mls, aes(x=height, y=weight, color=sport)) + geom_point(na.rm = TRUE)
```

**e)** (1 pont)

Ki tudjuk találni a sportágat?

- Az előző feladatban részletezett három sportág férfi sportolóinak sportágát szeretnénk megjósolni a magasság, súly és kor attribútumok alapján. Taníts naiv Bayes osztályozót a három sportág férfi sportolóit tartalmazó adatokok véletlenszerűen választott 2/3-án, és teszteld a maradék 1/3-on.
<p>><font size=2>Tipp: használd az *e1071* csomag *naiveBayes* függvényét!</font></p>
```{r}
#install.packages("e1071")
library(e1071)
#install.packages("dplyr")
library(dplyr)
```
```{r}
data <- select(mls, "height", "weight", "age", "sport")

ind <- sample(2, nrow(data), replace=TRUE, prob=c(0.67, 0.33))
data.training <- data[ind==1, 1:3]
data.test <- data[ind==2, 1:3]
data.test.sport <- data[ind==2, 4]

data.trainLabels <- as.factor(data[ind==1, 4])
data.testLabels <- as.factor(data[ind==2, 4])

nB <- naiveBayes(data.training, data.trainLabels)
pred <- predict(nB, data.test)
```

- Írd ki a tévesztési mátrixot (3x3-as mátrix lesz)!
<p>><font size=2>Tipp: használd a *table* függvényt!</font></p>
```{r}
tev_m <- table(pred, data.test.sport, dnn = c("prediction", "actual"))
tev_m
```

- Milyen arányban találta el a helyes címkét az algoritmus a tesztadatokon?
```{r}
sum(diag(tev_m))/sum(tev_m)
```

**f)** (2 pont)

Ismételd meg az előző feladat osztályozási feladatát, de most előbb diszkretizáld a három attribútumot!

- Mindhárom esetben hozz létre low, medium és high csoportokat az alsó és felső tercilisnek megfelelően. <p>><font size=2>Tipp: használd a *qunatile* függvényt!</font></p>
```{r}
data_disk <- select(mls, "height", "weight", "age", "sport")
data_disk[is.na(data_disk)] <- 0
tipusok = c("low", "medium", "high")

ht = quantile(data_disk$height, c(0:3/3))
wt = quantile(data_disk$weight, c(0:3/3))
at = quantile(data_disk$age, c(0:3/3))
data_disk$height = with(data_disk, cut(data_disk$height, ht, include.lowest = T, labels = tipusok))
data_disk$weight = with(data_disk, cut(data_disk$weight, ht, include.lowest = T, labels = tipusok))
data_disk$age = with(data_disk, cut(data_disk$age, ht, include.lowest = T, labels = tipusok))

ind <- sample(2, nrow(data_disk), replace=TRUE, prob=c(0.67, 0.33))
data.disk.training <- data_disk[ind==1, 1:3]
data.disk.test <- data_disk[ind==2, 1:3]
data.test.sport.disk <- data_disk[ind==2, 4]

data.disk.trainLabels <- as.factor(data_disk[ind==1, 4])
data.disk.testLabels <- as.factor(data_disk[ind==2, 4])

nB.disk <- naiveBayes(data.disk.training, data.disk.trainLabels)
pred.disk <- predict(nB.disk, data.disk.test)

tev_m.disk <- table(pred.disk, data.test.sport.disk, dnn = c("prediction", "actual"))
tev_m.disk
```
```{r}
sum(diag(tev_m.disk))/sum(tev_m.disk)
```

- Az e) vagy f) esetben teljesít jobban az osztályozó? 
```{r}
#Az e) esetben teljesít jobban az osztályozó.
```

- Írd ki az a priori osztályvalószínűségeket, és az attribútumok feltételes valószínűségeit az osztályváltozó értékét feltéve! (Ezeket az értékeket nem kell külön kiszámolni, egyszerűen lehívhatók a modellből.)
```{r}
print(nB)
```


```{r}
print(nB.disk)
```

**g)** (1 pont)

Az előzőekben használt sportolói adattábla alapján készíts egy olyan adattáblát, ami azt tartalmazza, hogy az adott sportból hány női, illetve hány férfi versenyző érkezett az olimpiára!
```{r}
sportok = athletes$sport[!duplicated(athletes$sport)]

ferfiak = c()
nok = c()
for (i in 1:length(sportok)){
    ferfiak[i] <- sum(athletes$sport==sportok[i] & athletes$sex=='male')
    nok[i] <- sum(athletes$sport==sportok[i] & athletes$sex=='female')
}

fok <- data.frame(sport = sportok, male = ferfiak, female = nok)
```

- Képezz új oszlopot: számold ki minden sporthoz a nők arányát.
```{r}
female_ratio <- c()
for(i in 1:length(fok$sport)) {
  female_ratio[i] <- fok$female[i]/(fok$male[i] + fok$female[i])
}
fok['female_ratio']<- female_ratio
```

- Írd ki a nők részvételi aránya alaján az első és az utolsó 5 sportágat. 
```{r}
fok_sorted <- fok[order(female_ratio),]
head(fok_sorted$sport, n = 5)
tail(fok_sorted$sport, n = 5)
```

**h)** (1 pont)

Töltsd be az Adatok mappában található countries_rio.csv fájlt!

- Az előzőekben használt sportolói adattábla alapján egészítsd ki az országok adattábláját egy új oszloppal, ami az adott ország összes megszerzett érmét tartalmazza! Figyelj arra, hogy az országok adattáblájában kevesebb ország szerepel, mint ahány országkód van a sportolói adattáblában (pl. a ROT - Refugee Olympic Team vagy az IOA - Independent Olympians nem szerpel), ezeket hagyd figyelmen kívül!
<p>><font size=2>Tipp: használd a *plyr* csomagból a *ddply* függvényt, majd használd a *merge* függvényt!</font></p>

- Képezz új oszlot az országok adattáblájában! Számold ki az adott országból érkező sportolók egy főre jutó számát (az ország népességéhez viszonyítva). Melyik országoknak a legnagyobb e mutatója? Írd ki a toplista első 10 helyezettjét!

- Ábrázold az érmek számát az egy főre jutó GDP függvényében pontfelhőként!

---

## 2. feladat (HF3/2) (5 pont)

Ebben a feladatban billentyűlenyomások nyers adataiból fogunk létrehozni idősoros adatokat, majd az idősorok között DTW távolságot számolunk.

**a)** (4 pont)

Idősorok létrehozása

- Töltsd be az Adatok mappában található raw_data.txt fájlt R-be. Ebben a fájlban néhány felhasználótól ugyanazon rövid szöveg többszöri begépeléséből származó billentyűlenyomási adatokat találod.
```{r}
library(stringr)

typing = readLines("../Adatok/raw_data.txt")
```

- Hozz létre kétfajta idősort (numerikus vektort) a nyers adatokból gépelésenkét!
<p>><font size=2>Tipp: hasznos függvények a beolvasához, majd a sorok szétvágáshoz: *readLines* és *strsplit*.</font></p>
    + Az első idősor tartalmazza a billentyűlenyomások időtartamát. Egy lenyomás időtartama alatt most az egymásnak megfelelő *keydown* és *keyup* események között eltelt időt értjük (milliszekundumban mérve). Ha az adat *keyup* eseménnyel kezdődik, azt az eseményt hagyd figyelmen kívül.
    + A másik idősor tartalmazza a lenyomások között eltelt időt, azaz két egymást követő *keydown* esemény között eltelt időt (milliszekundumban mérve).
       
**b)** (1 pont)

Az előző feladatrészben minden gépeléshez hozzárendeltél két idősort. 

- Most tekintsd *user1* és *user2* gépeléseit, és számold ki a DTW távolságot idősorfajtánként *user1* és *user2* saját gépelései között, majd egymás gépelései között is!
<p>><font size=2>Tipp: rendezd a kiszámolt távolságokat táblázatokba a jobb áttekinthetőség kedvéért!</font></p>

- Mit tapasztalsz? Alkalmas lehet a DTW távolság arra, hogy megkülönböztessük egymástól a felhasználókat gépelési szokásaik alapján?
<p>><font size=2>Tipp: használd a *dtw* csomag *dtw* fügvényét!</font></p>

**Néhány információ az adatról:**

- Minden gépelés így kezdődik a nyers adatban: "TYPING PATTERN"

- A második sor tartalmazza a gépelő felhasználónevét

- A következő két sor egyéb (számunkra most nem fontos) információt tartalmaz (mikor gépelte le a szöveget, mennyire volt fáradt önbevallás alapján)

- Az ötödik sortól kezdődően a gépelési események szerpelnek. Minden sorban az alábbiak:
    * a gépelési esemény típusa *(keydown/keyup/keypress)*
    * event.keycode (a *keyCode* mező a hozzátartozó JavaScript eseménynél)
    * event.which
    * evenet.charCode
    * event.shiftKey
    * a JavaScript Date.getTime() függvény visszatérési értéke, azaz 1970. január 1. óta eltelt milliszekundumok száma
    
 
**A feladat megoldása szempontjából az esemény típusa, a keycode mező és az idő (milliszekundumok száma) az érdekesek számunkra!**

---