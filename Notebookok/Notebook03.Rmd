---
title: "Notebook03"
output:
  html_document: default
  html_notebook: default
---
# Bevezetés az adattudományba 1.
## Néhány dolog R-ben

### Egy-két alapdolog
Hol vagyunk?
```{r}
getwd()
```
Munkakönyvtár beállítása
```{r, eval=FALSE, include=TRUE}
setwd()
```

Mi van az "Environment"-ben?
```{r}
a <-3
ls()
```
Töröljük ki:
```{r}
rm(a)
```

Most?
```{r}
ls()
```

Hozzunk létre vektorokat!

```{r}
v1 <- c(1, 2.0, -3, 100, -3, 7.5)
v1
```
```{r}
v2 <- c('ez', 'az', 'amaz')
v2
```

A summary különböző típusú objektumokra különböző outputokat ad:
```{r}
summary(v1)
```
```{r}
summary(v2)
```
Alapértelmezetten a 0, 25, 50, 75, 100 kavantiliseket adja vissza, de paramétezerhető:
```{r}
quantile(v1)
```

### Egy kevés a mátrixokról
Egy márix:
```{r}
ma = matrix(1:6, nrow=3, ncol=2)
ma
```
Egy másik mátrix:
```{r}
mb = matrix(7:9, nrow=3, ncol=1)
mb
```
Vonjuk őket össze
```{r}
m = cbind(ma, mb)
m
```
És soronként?
```{r, eval=FALSE, include=TRUE}
rbind(ma, mb)
```
Mátrixok elemei
```{r}
m[1, 3]
m[1, 1:3]
m[1, ]
m[, 1:2]
```
Néhány egyéb hasznos függvény
```{r}
nrow(m)
ncol(m)
dim(m)
```
Transzponálás
```{r}
t(m)
```
A diag függvény
```{r}
diag(m)
diag(3)
diag(c(1,2,3))
```

### Listák
```{r}
mylist = list(v1,v2,ma)
mylist
```
Hívjuk le egy elemét!
```{r}
mylist[3]
```
```{r}
class(mylist[3])
```
Most másképp!
```{r}
mylist[[3]]
```
```{r}
class(mylist[[3]])
```
### Data frame-ek
Tölstünk be R-be beépített adatot
```{r}
data(mtcars)
class(mtcars)
```
```{r}
head(mtcars)
```
```{r}
summary(mtcars)
```
Lekérhetjük az oszlopneveket
```{r}
colnames(mtcars)
```
Egy oszlop kiválasztása
```{r}
mtcars$mpg
```
Másképp
```{r}
mtcars[, "mpg"]
```
Megint másképp
```{r}
mtcars[, 1]
```
Sorokat kiválasztva
```{r}
mtcars[1:3, ]
```
Kis fogyasztású autók kiválasztása
```{r}
efficient.cars = mtcars[mtcars$mpg > 20, ]
head(efficient.cars)
```
Több feltétel egyszerre
```{r}
efficient.auto = mtcars[mtcars$mpg > 20 & mtcars$am == 0, ]
head(efficient.auto)
```
Azon sorok megtartása, melyek hiánytalanok
```{r}
data(airquality)
head(airquality)
```
```{r}
good = complete.cases(airquality)
airquality[good, ][1:6, ]
```

### Adatok beolvasása
```{r}
bankdata <- read.csv("../Adatok/bank.csv", sep=" ", header = FALSE)
head(bankdata)
```
Közvetlenül internetről
```{r}
movielens <- read.csv(url('http://files.grouplens.org/datasets/movielens/ml-100k/u.user'), sep='|', header = FALSE)
head(movielens)
```

Szöveges fájl soronkénti beolvasása (fájlból vagy internetről)
```{r}
readLines("http://math.bme.hu/~molontay", 10)
```
### Vizualizáció
A ggplot csomagot fogjuk használni ezt instalálni kell (ha még nem tettük meg)
```{r}
# install.packages("ggplot2")
```
Használat előtt pedig mindig be kell hívni a már telepített csomagokat!
```{r}
library("ggplot2")
```
Töltsünk be adatot
```{r}
data("diamonds")
head(diamonds)
```
Ggplot vizualizáció három alap összetevőből áll

* az adat, amit vizualizálunk
* "aesthetic", azaz a dimenziók (pl.: x, y, pont színe, mérete stb.), ami mentén vizualizálunk
* a rétegek (layer), amit az ábrához hozzáadunk
```{r}
ggplot(diamonds, aes(x=carat, y=price)) + geom_point()
```

Adjunk hozzá egy új "dimenziót"!

```{r}
ggplot(diamonds, aes(x=carat, y=price, color=clarity)) + geom_point()
```
És még egyet!
```{r}
ggplot(diamonds, aes(x=carat, y=price, color=clarity, size=cut)) + geom_point()
```
Szerkesszünk rá trendvonalat konfidenciaintervallummal!
```{r}
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + geom_smooth()
```
Ezt megtehetjünk színenként is!
```{r}
ggplot(diamonds, aes(x=carat, y=price, color=clarity)) + geom_point() + geom_smooth(se=FALSE)
```
ÉS mi van, ha csak a trendvonalaakt szeretnénk pontok nélkül?
```{r}
ggplot(diamonds, aes(x=carat, y=price, color=clarity)) + geom_smooth(se=FALSE)
```

Külön ábra clarity változók szerint bontva
```{r}
ggplot(diamonds, aes(x=carat, y=price, color=cut)) + geom_point() + facet_wrap(~ clarity)
```
Cím hozzáadása
```{r}
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + ggtitle("My scatter plot")
```
Tengelyfeiratok hozzáadása
```{r}
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + ggtitle("My scatter plot") + xlab("Weight (carats)")
```
Egy tengely bekorlátozása
```{r}
ggplot(diamonds, aes(x=carat, y=price)) + geom_point() + ggtitle("My scatter plot") + xlab("Weight (carats)") + xlim(0, 2)
```
Hisztogram létrehozása
```{r}
ggplot(diamonds, aes(x=price)) + geom_histogram()
```
Szélesség beállítása
```{r}
ggplot(diamonds, aes(x=price)) + geom_histogram(binwidth=200)
```
Hisztogram clarity-ként
```{r}
ggplot(diamonds, aes(x=price)) + geom_histogram(binwidth=200) + facet_wrap(~ clarity, scale="free_y")
```
Újabb "asthetic" a "fill"
```{r}
ggplot(diamonds, aes(x=price, fill=clarity)) + geom_histogram()
```
Boxplot
```{r}
ggplot(diamonds, aes(x=color, y=price)) + geom_boxplot()
```
Logaritmikus skálán:
```{r}
ggplot(diamonds, aes(x=color, y=price)) + geom_boxplot() + scale_y_log10()
```

### Az apply függvénycsalád - "egysoros for ciklus""

* lapply: Egy lista minden elemére lefuttatja ugyanazt a függvényt
* sapply: Uaz, mint az lapply, csak próbálja egyszerűbben kiírni az
eredményt
* apply: egy többdimenziós objektum (mátrix vagy data frame) soraira
ill. oszlopaira futtatunk le valammit
* mapply: több argumentumú függvényt futtat le úgy, hogy az
argumentumok több listából jönnek

```{r}
lapply(1:3, function(n) n*n)
```
Oszlopokra alkalmazva
```{r}
x <- matrix(rnorm(200), 20, 10)
apply(x, 2, function(i) mean(i**2))
```
### Gépi tanulás R-ben
Sok különböző csomag van, sok algoritmus több csomagban is benne van

kNN az iris adatokon

```{r}
#install.packages("class")
```
```{r}
library("class")
```
Normalizáljuk az adatot
```{r}
# Build your own `normalize()` function
normalize <- function(x) {
num <- x - min(x)
denom <- max(x) - min(x)
return (num/denom)
}

# Normalize the `iris` data
iris_norm <- as.data.frame(lapply(iris[1:4], normalize))

# Summarize `iris_norm`
summary(iris_norm)
```

Tanító és tesztadatok megalkotása
```{r}
ind <- sample(2, nrow(iris), replace=TRUE, prob=c(0.67, 0.33))
# Compose training set
iris.training <- iris[ind==1, 1:4]

# Inspect training set
head(iris.training)

# Compose test set
iris.test <- iris[ind==2, 1:4]

# Inspect test set
head(iris.test)
```
Címkék kialakitása

```{r}
# Compose `iris` training labels
iris.trainLabels <- iris[ind==1,5]

# Inspect result
print(iris.trainLabels)

# Compose `iris` test labels
iris.testLabels <- iris[ind==2, 5]

# Inspect result
print(iris.testLabels)
```

Modell
```{r}
# Build the model
iris_pred <- knn(train = iris.training, test = iris.test, cl = iris.trainLabels, k=3)

# Inspect `iris_pred`
iris_pred
```

Sok csomag gépi tanulási algoritmusa az alábbi szintakitikát használja

```{r}
# install.packages("tree")
```

```{r}
library("tree")
ir.tr <- tree(Species ∼., iris)
summary(ir.tr)
``` 

```{r}
plot(ir.tr)
text(ir.tr)
``` 