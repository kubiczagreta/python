---
title: "Notebook05"
output:
  html_document: default
  html_notebook: default
---
# Bevezetés az adattudományba 1.
## Ügyfélszegmentáció klaszterezéssel
Anna Leontjeva nyomán

### Szegmentálás kézzel
Adatok betöltése

```{r}
orders <- read.csv("../Adatok/orders_rfm.txt")
head(orders)
```

Előkészítés

```{r}
orders$order_date <- as.Date(orders$order_date, format='%Y-%m-%d') # transform to date format
reporting_date <- max(orders$order_date) # the date of the last available purchase
reporting_date
```

Hány ügyfélről vannak adataink?

```{r}
length(unique(orders$client_id))
```

Milyen termékeket vásároltak?

```{r}
table(orders$product)
```

#### Aggregálás dplyr csomag segítéségvel
Megfelelő attribútumok létrehozása 

```{r}
# install.packages("dplyr")
library(dplyr)
frm_tbl_initial <- orders %>%
  group_by(client_id) %>%
  summarise(order_frequency = n(), order_recency = min(reporting_date - order_date), 
            order_monetary = sum(money_spent))
head(frm_tbl_initial)
```

A "recency" változónak furcsa a típusa

```{r}
class(frm_tbl_initial$order_recency)
```

Alakítsuk át!

```{r}
frm_tbl_initial$order_recency <- as.numeric(frm_tbl_initial$order_recency) 
```

Nézzünk rá a hisztogramokra!

```{r}
library(ggplot2)
ggplot(frm_tbl_initial, aes(x=order_recency)) + geom_histogram(fill='#8b3840', color='grey60', binwidth = 1)

```
```{r}
ggplot(frm_tbl_initial, aes(x=order_frequency)) + geom_histogram(fill='#8b3840', color='grey60', binwidth=1)

```

Most fel fogjuk vágni (diszkretizálás) az értékeket!
Ehhez előbb kérjünk le egy összegző statisztikát!

```{r}
summary(frm_tbl_initial) # to explore limits
```

Most vágjunk, lehetne a kvantilisek szerint is, most mi "szakértői tudásunkat" kihasználva hasraütésszerűen máshogyan vágunk!

```{r}
fr_tbl <- mutate(frm_tbl_initial, frequency_bins = cut(order_frequency, breaks=c(0,1,2,10,30,32)))
table(fr_tbl$frequency_bins)
```
```{r}
fr_tbl <- mutate(fr_tbl, recency_bins = cut(order_recency, breaks=c(-1,7,14,31,61,100)))
table(fr_tbl$recency_bins)
```

Hasonlóan vághatnánk a monetary értékeket is.
Most maradjunk ennél a két dimenziónál, és nézzük az egyes mezőkbe hányan kerültek?

```{r}
table(frequency=fr_tbl$frequency_bins, recency=fr_tbl$recency_bins)
```

Csináljunk ábrákat a könnyebb érthetőség kedvéért!

```{r}
fr_tbl_counts <- fr_tbl %>% group_by(frequency_bins, recency_bins) %>% summarise(count=n())
p_basic <- ggplot(fr_tbl_counts, aes(x=recency_bins, y=frequency_bins)) + geom_tile(aes(fill=count))+ 
  geom_text(aes(label = count)) +
  scale_fill_gradient(low='#f0f0f0', high="#636363") + theme_bw(base_size=20)
p_basic
```

Csoportosítsuk őket (most csak hasunkra ütünk, és berajzolunk vonalakat)

```{r}
p_quadrants <- p_basic +
  annotate("rect", xmin = 0, xmax=3.47, ymin=3.47, ymax=6, color='green', alpha=0.1, fill='green') +
  annotate("rect", xmin = 0, xmax=3.47, ymin=2.5, ymax=3.47, color='yellow', alpha=0.1, fill='yellow') +
  annotate("rect", xmin = 0, xmax=3.47, ymin=0, ymax=2.5, color='blue', alpha=0.1, fill='blue') +
  annotate("rect", xmin = 3.5, xmax=6, ymin=3.47, ymax=6, color='red', alpha=0.1, fill='red') +
  annotate("rect", xmin = 3.5, xmax=6, ymin=0, ymax=3.47, color='black', alpha=0.1, fill='black')
p_quadrants
```

Értelmezzük a látottakat:

```{r}
p_quadrants + annotate("text", x=1.8, y=5.8, label='New customers') +
  annotate("text", x=4.8, y=5.8, label='Hibernating loyal customers') +
  annotate("text", x=1.4, y=2.7, label='Promising') +
  annotate("text", x=1.8, y=0.2, label='Loyal') +
  annotate("text", x=4.8, y=0.2, label='Lost')
```

### Szegmentálás klaszterező algoritmussal (K-közép)
Az attribútumokat célszerű először skálázni, hisz a távolság alapú módszereknél ez nagyon fontos!

```{r}
data_clustering <- frm_tbl_initial %>%
  mutate(order_frequency=scale(order_frequency), 
         order_recency=scale(order_recency), 
         order_monetary=scale(order_monetary))
head(data_clustering)
```

Hajtsuk végre a klaszterezést!

```{r}
clusters <- kmeans(data_clustering[,-1], centers = 4, nstart=20)
clusters
```

Adjuk hozzá az ügyfelekhez a kijövő klasztersoszámokat, és ábrázoljuk az adatokat!

```{r}
data_clustering$cluster <- as.factor(clusters$cluster) # we need it to be a factor for the plot
ggplot(data_clustering, aes(x=order_frequency, y=order_recency, color=cluster)) + geom_point(size=2)

```

Ez persze csak egy fajta szelet, ábrázoljuk az összes kétdimenziós szeletet:

```{r}
# install.packages("gridExtra")
library(gridExtra)
p1 <- ggplot(data_clustering, aes(x=order_frequency, y=order_recency, color=cluster)) + geom_point(size=2) + theme_bw()
p2 <- ggplot(data_clustering, aes(x=order_frequency, y=order_monetary, color=cluster)) + geom_point(size=2) + theme_bw()
p3 <- ggplot(data_clustering, aes(x=order_monetary, y=order_recency, color=cluster)) + geom_point(size=2) + theme_bw()
grid.arrange(p1,p2,p3, nrow=3)
```

A klaszterszámnak (K-nak) a 4-et mi kedvünkre választottuk.
Nézzük, mit mondana rá a "könyökszabály"?

```{r}
library(dplyr)
# finding optimal number of clusters
elbow_method <- function(data, max_k=15){
  require(ggplot2)
  wss <- (nrow(data)-1)*sum(apply(data,2,var))
  for (i in 1:max_k){
    wss[i] <- sum(kmeans(data_clustering, centers=i)$withinss)
  }
  p <- data.frame(number_of_clusters=c(1:max_k), wss=wss) %>%
    ggplot(aes(x=number_of_clusters, y=wss, group=1)) + geom_point() + 
    geom_line() + theme_bw() + ylab("Within groups sum of squares")
  return(print(p))
}

# apply the function
elbow_method(data_clustering[,-1], max_k=15)
```

#### Hierarchikus klaszterezés

```{r}
distance_m <- dist(as.matrix(frm_tbl_initial[,-1])) # we can define other distances. take a look at ?dist
hc <- hclust(distance_m)
plot(hc)
```

Ez persze nem túl szép, lehetne szebbé tenni, ettől mi most itt eltekitünk!